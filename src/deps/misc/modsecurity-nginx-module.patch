@@ -36,7 +36,75 @@
 static char *ngx_http_modsecurity_merge_conf(ngx_conf_t *cf, void *parent, void *child);
 static void ngx_http_modsecurity_cleanup_instance(void *data);
 static void ngx_http_modsecurity_cleanup_rules(void *data);
+static ngx_int_t ngx_http_modsecurity_get_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data);
+static ngx_int_t ngx_http_modsecurity_add_variables(ngx_conf_t *cf);
+ 
+static ngx_http_variable_t modsecurity_variables[] = {
+    { ngx_string("modsecurity_reason"), NULL, ngx_http_modsecurity_get_variable, (uintptr_t) "tx:bunkerweb_reason", NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE },
+    { ngx_string("modsecurity_unique_id"), NULL, ngx_http_modsecurity_get_variable, (uintptr_t) "tx:bunkerweb_unique_id", NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE },
+    { ngx_string("modsecurity_rules"), NULL, ngx_http_modsecurity_get_variable, (uintptr_t) "tx:bunkerweb_rules", NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE },
+    { ngx_string("modsecurity_msgs"), NULL, ngx_http_modsecurity_get_variable, (uintptr_t) "tx:bunkerweb_msgs", NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE },
+    { ngx_string("modsecurity_matched_vars"), NULL, ngx_http_modsecurity_get_variable, (uintptr_t) "tx:bunkerweb_matched_vars", NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE },
+    { ngx_string("modsecurity_matched_var_names"), NULL, ngx_http_modsecurity_get_variable, (uintptr_t) "tx:bunkerweb_matched_var_names", NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE },
+    { ngx_string("modsecurity_anomaly_score"), NULL, ngx_http_modsecurity_get_variable, (uintptr_t) "tx:bunkerweb_anomaly_score", NGX_HTTP_VAR_CHANGEABLE|NGX_HTTP_VAR_NOCACHEABLE },
+    ngx_http_null_variable
+};
+
+static ngx_int_t
+ngx_http_modsecurity_get_variable(ngx_http_request_t *r,
+                                ngx_http_variable_value_t *v,
+                                uintptr_t data)
+{
+    ngx_http_modsecurity_ctx_t *ctx;
+    const char *var_name = (const char *)data;
+
+    ctx = ngx_http_modsecurity_get_module_ctx(r);
+    if (ctx == NULL || ctx->modsec_transaction == NULL) {
+        v->not_found = 1;
+        return NGX_OK;
+    }
+
+    const char *value = msc_get_transaction_variable(ctx->modsec_transaction, var_name);
+
+    if (value == NULL) {
+        v->not_found = 1;
+        return NGX_OK;
+    }
+
+    size_t len = ngx_strlen(value);
+    u_char *p = ngx_pnalloc(r->pool, len);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_memcpy(p, value, len);
 
+    v->data = p;
+    v->len = len;
+    v->valid = 1;
+    v->no_cacheable = 1;
+    v->not_found = 0;
+
+    return NGX_OK;
+}
+
+static ngx_int_t
+ngx_http_modsecurity_add_variables(ngx_conf_t *cf)
+{
+    ngx_http_variable_t  *var, *v;
+
+    for (v = modsecurity_variables; v->name.len; v++) {
+        var = ngx_http_add_variable(cf, &v->name, v->flags);
+        if (var == NULL) {
+            return NGX_ERROR;
+        }
+
+        var->get_handler = v->get_handler;
+        var->data = v->data;
+    }
+
+    return NGX_OK;
+}
 
 /*
  * PCRE malloc/free workaround, based on
@@ -552,7 +620,7 @@
 ngx_http_modsecurity_init(ngx_conf_t *cf)
 {
     ngx_http_handler_pt *h_rewrite;
-    ngx_http_handler_pt *h_preaccess;
+    ngx_http_handler_pt *h_access;
     ngx_http_handler_pt *h_log;
     ngx_http_core_main_conf_t *cmcf;
     int rc = 0;
@@ -582,18 +650,18 @@
 
     /**
      *
-     * Processing the request body on the preaccess phase.
+     * Processing the request body on the access phase.
      *
      * TODO: check if hook into separated phases is the best thing to do.
      *
      */
-    h_preaccess = ngx_array_push(&cmcf->phases[NGX_HTTP_PREACCESS_PHASE].handlers);
-    if (h_preaccess == NULL)
+    h_access = ngx_array_push(&cmcf->phases[NGX_HTTP_ACCESS_PHASE].handlers);
+    if (h_access == NULL)
     {
-        dd("Not able to create a new NGX_HTTP_PREACCESS_PHASE handle");
+        dd("Not able to create a new NGX_HTTP_ACCESS_PHASE handle");
         return NGX_ERROR;
     }
-    *h_preaccess = ngx_http_modsecurity_pre_access_handler;
+    *h_access = ngx_http_modsecurity_access_handler;
 
     /**
      * Process the log phase.
@@ -621,7 +689,8 @@
         return rc;
     }
 
-    return NGX_OK;
+    // Process variables
+    return ngx_http_modsecurity_add_variables(cf);
 }
 
 
